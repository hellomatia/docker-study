# Docker

## 모던 웹개발에서 Docker 가 왜 필요해졌을까? 
### 도출되는  두  가지  질문
- 컨테이너는  무엇일까? 
- 컨테이너를  왜  사용하는가?
```text
"자신이 해결해야 할 문제가 과연 제대로 된 문제인지 처음부터 신중하게 고려하기 바란다. 가령 다음 지 침은 성능 문제의 탈을 쓰고 있지만 사실상 구현 문제를 제기한다. ‘성능을 높이기 위 해 애플리케이션을 마이크로서비스 단위로 쪼개고 컨테이너화시킬 것’. 제대로 된 문제는 다음과 비 슷하다. ‘고객들의 목표완수 시간을 단축하기 위해 애플리케이션 성능을 5% 향상시킬 것’. 후자는 결과 성공 여부를 측정할 수 있는 실질적 메트릭metric을 포함하고 있으며 실현 방법도 마이크 로서비스 구현으로 한정 짓지 않는다." - from. '자바 개발자를 위한 데브옵스 툴'
```
### 컨테이너가  걸어온  역사
- 1960-70년대 - 한  컴퓨터가  한  애플리케이션  실행을  담당하는  것이  일반적. 프로세스도  오래  걸림 
- 이대로는 안되겠다. 컴퓨팅 자원을 최대한 쉐어해서 써서 빠르게 만들자. -> 여러 사용자가 자원을 사용 하게 되면서 서로 간섭이 일어나는 경우가 생겨버림. -> 한명의 사용자가 시스템을 중단시켜버리는 경우 까지 발생

- 예를  들어, 하나의  프로그램이  사용하는  리소스를  다 사용해버리는  경우나  프로그램  에러가  나서 OS 까지  영향을  미쳐버릴  때 그럼  어떻게  해야할까?

- 소프트웨어  서비스  장애 -> 효율적으로  사용해야함. 자원을  분리해서  사용 

- '가상화'(virtualization) 사용해서  하나의  컴퓨터에서  여러  애플리케이션  구동. 

- 가상화는  원래  있었음 -> VM(Virtual Machine)
```
하이퍼바이저 가상화는 하드웨어 상에 여러 개의 독립적인 가상 운영 체제(가상 머신)를 실행할 수 있게 해주는 기술이다. 이를 통해 하나의 물리적 컴퓨터 내에서 여러 운영 체제를 동시에 실행할 수 있다. 각 가상 머신은 독립적인 컴퓨팅 환경을 제공받으며, 기본적인 하드웨어 자원(CPU, 메모리, 스토리지 등)은 물리적 호스트 시스템에 의해 가상화된 형태로 할당된다.
하이퍼바이저 가상화의 핵심은 하이퍼바이저라는 소프트웨어에 있다. 하이퍼바이저는 물리적 하드웨어 와 가상 머신 사이에서 중재자 역할을 하며, 하드웨어 자원을 가상 머신에게 분배하고, 가상 머신들이 이 자원을 안전하고 효율적으로 사용할 수 있도록 관리한다. 가상화를 통해, 개발자는 다양한 운영 체제 위에서 애플리케이션을 테스트하고, IT 관리자는 서버를 더 효율적으로 활용하여 비용을 절감하며, 보안성이 높은 격리된 환경을 구성할 수 있다. 또한, OS 가상화는 클라우드 컴퓨팅, 재해 복구, 시스템 마이그레이션과 같은 다양한 IT 요구 사항을 충족시키는 데 핵심적인 역할을 한다.
```
- VM 과  다른  방법을  사용해서  효율  성능이  더  나아진  게  컨테이너
- 컨테이너 가상화는 애플리케이션을 실행하는 데 필요한 코드, 런타임, 시스템 도구, 시스템 라이브러리 등을 포함하는 가벼운, 격리된 환경을 생성하는 기술이다. 컨테이너는 가상 머신과 달리 운영 체제 수준에서 격리되며, 하나의 호스트 시스템에서 여러 컨테이너를 실행할 수 있어 자원을 효율적으로 사용한다. 리눅스의 핵심 격리 기술을 기반으로 하여, 하나의 리눅스 커널 위에서 여러 개의 독립적인 사용자 공간 인스턴스를 실행할 수 있게 해준다. 이러한 격리는 주로 리눅스의 두 가지 핵심 기능, 즉 Cgroups(Control Groups)와 네임스페이스(Namespace)를 활용하여 이루어진다.
```
Cgroups (Control Groups)
Cgroups는 프로세스 그룹의 리소스 사용량(예: CPU 시간, 시스템 메모리, 네트워크 대역폭)을 모니터링하고 제한하는 기능을 제공한다. 이를 통해 각 컨테이너가 할당된 자원을 초과하여 사용하는 것을 방 지함으로써, 시스템의 안정성을 유지하고 다른 컨테이너 또는 시스템 전체에 미치는 영향을 최소화한다.
```

```
네임스페이스 (Namespace)
네임스페이스는 프로세스에게 제한된 시스템 뷰를 제공하여, 프로세스가 자신의 네임스페이스 내에서만 시스템 리소스를 볼 수 있도록 한다. 이를 통해 파일 시스템 마운트, 네트워크, 사용자 ID, 호스트 이름 등을 각 컨테이너마다 독립적으로 할당하고 관리할 수 있다. 네임스페이스는 컨테이너를 격리된 환경으로 만들어 주는 핵심 기술로, 컨테이너 내부에서 실행되는 프로세스가 호스트 시스템이나 다른 컨테이너의 리소스와 충돌하지 않도록 한다.
```
- Cgroups 와 네임스페이스  는  리눅스  커널의  두  가지  핵심  기술로, 컨테이너  가상화의  기반을  이룬다. 여기서 

- Cgroups (Control Groups) 예시
예를  들어, 시스템에  여러  컨테이너가  실행  중이고, 각각  다른  애플리케이션이  작동하고  있다고  가정해보자. 여기서  한  컨테이너가  너무  많은 CPU 시간을  사용하여  시스템의  다른  부분에  영향을 미치기  시작한다면, 시스템  관리자는 Cgroups를  사용하여  그  컨테이너의 CPU 사용량을  제한할 수  있다. 예를  들어, cpu.shares 파라미터를  조정하여  특정  컨테이너  그룹이  사용할  수  있는 CPU 자원의  양을  조절할  수  있다. 이는  시스템  자원이  공정하게  분배되도록  보장하고, 한  애플리케이션이  전체  시스템을  점유하는  것을  방지한다.

- 네임스페이스 (Namespace) 예시
네임스페이스는 시스템 리소스를 격리하여 프로세스 그룹이 해당 리소스를 독립적으로 보고 관리할 수 있게 한다. 예를 들어, PID (Process ID) 네임스페이스 를 사용하는 경우, 각 컨테이너는 자체적인 PID 1부터 시작하는 고유한 프로세스 번호 공간을 가지게 된다. 이는 컨테이너 내부에서 실행되는 프로세스가 시스템의 다른 부분이나 다른 컨테이너의 프로세스와 독립적으로 관리될 수 있음을 의미한다. 결과적으로, 컨테이너 내부의 애플리케이션은 자신이 전체 시스템에서 유일하게 실행되고 있는 것처럼 동작할 수 있으며, 이는 보안과 격리를 강화한다.- 리눅스의 이러한 격리 기술을 사용함으로써, 컨테이너 가상화는 각 컨테이너에게 겉보기에는 완전히 독립된 시스템처럼 보이는 환경을 제공한다. 이는 개발자가 애플리케이션을 개발하고 배포할 때 발생할 수 있는 "작동하지 않음" 문제를 크게 줄여주며, 애플리케이션의 이식성을 크게 향상시킨다.

```
- [용어] container
- https://www.docker.com/resources/what-container/
- "개발, 배송 및 배포를 위해 소프트웨어를 표준화된 단위로 패키징- 컨테이너는 애플리케이션이 한 컴퓨팅 환경에서 다른 컴퓨팅 환경으로 빠르고 안정적으로 실행될 수 있도록 코드와 모든 종속성을 패키지화하는 소프트웨어의 표준 단위입니다.
- "Docker 컨테이너  이미지는  코드, 런타임, 시스템  도구, 시스템  라이브러리  및  설정  등  애플리케이션을  실행하는데  필요한  모든  것을  포함하는  경량의  독립형  실행  가능  소프트웨어  패키지입니다."
```

## DockerEngine

도커 엔진은 컨테이너를 생성하고 관리하는 기능을 제공하는 클라이언트-서버 형태의 애플리케이션이다.

- **도커 데몬:** 컨테이너 관리를 위한 백그라운드 프로세스로, 이미지 생성, 컨테이너 실행, 네트워크 설정 등의 작업을 수행한다. 이는 컨테이너의 생성, 실행, 중지와 같은 생명 주기를 관리한다. 또한, 이미지를 빌드하고 저장소에서 이미지를 가져오는 역할을 수행한다. 도커 데몬은 다른 도커 클라이언트의 명령을 수행하기 위해 REST API를 통해 접근할 수 있다.
- **REST API:** 도커 데몬과 통신하는 인터페이스로, 이 API를 통해 다양한 도커 클라이언트가 도커 데몬과 상호작용할 수 있다. 이를 통해 애플리케이션의 배포, 관리, 확장을 위한 다양한 명령을 수행할 수 있다.
- **CLI 클라이언트:** 사용자가 커맨드 라인을 통해 도커 엔진과 상호작용할 수 있게 하는 인터페이스다. 사용자는 이를 통해 컨테이너를 생성하고 관리할 수 있으며, 이미지를 빌드하고 도커 허브 같은 이미지 저장소와 상호작용 할 수 있다.

### 동작 방식

도커 엔진의 동작 방식은 기본적으로 컨테이너의 생명 주기 관리와 관련된 일련의 과정을 포함한다. 사용자 또는 애플리케이션은 도커 CLI 또는 API를 통해 도커 데몬과 상호작용하며, 도커 데몬은 이러한 명령을 수행하여 컨테이너를 생성, 실행, 중지 등의 작업을 관리한다.

1. **이미지 다운로드 또는 빌드**: 컨테이너를 실행하기 전에, 도커 엔진은 해당 애플리케이션을 실행하는 데 필요한 모든 파일과 설정이 포함된 도커 이미지가 필요하다. 사용자는 도커 허브나 다른 이미지 저장소에서 이미지를 다운로드하거나, Dockerfile 을 정의하고 이를 통해 새로운 이미지를 빌드할 수 있다.
2. **컨테이너 생성:** 이미지가 준비되면, 사용자는 도커 데몬에게 컨테이너 생성을 요청한다. 이때, 네트워크 설정이나 볼륨 마운트와 같은 추가적인 옵션을 지정할 수 있다. 도커 데몬은 이러한 정보를 바탕으로 새로운 컨테이너의 인스턴스를 생성한다.
3. **컨테이너 실행:** 컨테이너가 생성되면, 도커 데몬은 컨테이너 내부에서 정의된 애플리케이션을 실행한다. 이 과정에서 컨테이너는 독립된 파일 시스템, 네트워크 인터페이스, 프로세스 ID 공간 등을 갖게 되며, 이는 컨테이너를 호스트 시스템과 격리된 환경에서 실행되게 한다.
4. **컨테이너 관리:** 도커 엔진은 실행 중인 컨테이너의 상태를 모니터링하고 관리한다. 사용자는 도커 CLI를 통해 실행 중인 컨테이너를 조회하고, 로그를 확인하며, 필요한 경우 컨테이너를 중지, 재시작 또는 삭제할 수 있다.
5. **리소스 관리:** 도커 엔진은 Cgroups와 네임스페이스와 같은 리눅스의 핵심 기능을 사용하여 컨테이너의 리소스 사용량을 제한하고, 컨테이너 간의 격리를 유지한다. 이를 통해 시스템의 안정성을 보장하고, 다른 컨테이너나 시스템 전체에 부정적인 영향을 미치는 것을 방지한다.

<aside>
💡 **Docker Image**
도커 이미지는 컨테이너를 실행하기 위한 불변의 템플릿이다. 이 이미지는 애플리케이션 실행에 필요한 모든 것을 포함한다 
— 코드, 런타임, 애플리케이션과 관련된 라이브러리, 환경 변수 및 설정 파일 등. 도커 이미지는 여러 계층으로 구성되어 있으며, 각 계층은 변경 사항을 저장한다. 이미지는 컨테이너를 생성하는 데 사용되며, 일반적으로 도커허브와 같은 레지스트리에서 가져오거나 Dockerfile 을 사용해 직접 빌드할 수 있다.

**Docker container**
도커 컨테이너는 도커 이미지의 실행 인스턴스이다. 컨테이너는 이미지를 기반으로 하여 실행되며, 격리된 환경에서 애플리케이션과 그 의존성을 캡슐화한다. 컨테이너는 가벼우며 시스템 리소스를 효율적으
로 사용한다는 장점이 있다. 컨테이너는 시작될 때 생성되고 종료될 때 제거된다. 개발자는 동일한 이미지를 사용하여 여러 컨테이너를 동시에 실행할 수 있으며, 각 컨테이너는 독립적으로 실행되고 관리된
다.

**DockerFile**
Dockerfile 은 도커 이미지를 자동으로 빌드하기 위한 스크립트 파일이다. 이 파일은 기본 이미지 설정, 실행할 명령어, 추가할 파일 및 디렉토리, 환경 변수 설정 등 이미지 생성에 필요한 지시어를 담고 있
다. Dockerfile 은 docker build 명령어와 함께 사용되어 새로운 도커 이미지를 생성한다. Dockerfile 을 사용하면 애플리케이션의 배포 과정을 표준화하고 자동화할 수 있으며, 필요한 모든 설정과 의존성이 문서화되어 재현 가능하다.

**Docker Hub**
도커허브는 도커 이미지를 찾고, 공유하고, 관리할 수 있는 공식적인 클라우드 기반 서비스 및 저장소이다. 사용자는 도커허브에서 수많은 공개 도커 이미지를 무료로 다운로드할 수 있으며, 자신의 도커 이미
지를 업로드하여 공개하거나 비공개로 저장할 수도 있다. 도커허브는 개발자와 조직이 컨테이너화된 애플리케이션을 쉽게 배포하고 공유할 수 있도록 지원하는 중앙 집중식 서비스이다. 도커허브는 또한 자동 이미지 빌드, 웹훅, 조직 및 팀을 위한 협업 툴 등과 같은 추가 기능을 제공한다.

**Docker Registry**
도커 리지스트리는 도커 이미지를 저장하고 배포하기 위한 서버 측 응용 프로그램이다. 도커허브와 유사 하게 동작하지만, 도커 리지스트리는 사용자가 자신의 서버에 직접 설치하여 개인 또는 조직 내부에서
사용할 수 있는 프라이빗 저장소를 만들 수 있게 해준다. 이는 비공개 프로젝트나 내부적으로 사용되는 이미지를 안전하게 관리하고 싶은 조직에 적합한 솔루션이다. 도커 리지스트리는 보안, 액세스 제어, 저
장소 한계 설정 등을 사용자가 직접 구성할 수 있게 해주며, 이를 통해 개인화된 컨테이너 이미지 저장소를 운영할 수 있다. 도커 리지스트리 소프트웨어는 오픈 소스이며, Docker Inc.에 의해 관리된다.

</aside>

## 로컬 환경에서 Docker 실행

```sql
docker run -p 8080:8080 -t spring-helloworld // 1번
docker run -d -p 8080:8080 -t spring-helloworld // 2번
```

위 두 명령어의 차이점은 포그라운드에서 실행 할지, 백그라운드에서 실행할지 에 있다.

- 1번
    - 이 명령어는 spring-helloworld 이미지를 사용하여 컨테이너를 포그라운드 모드로 실행한다.
    - -t 옵션은 터미널을 할당하며, 이는 컨테이너의 표준 출력을 현재 쉘의 표준 출력에 연결한다.
    - 이 모드에서는 컨테이너의 로그를 직접 볼 수 있고, 컨테이너가 실행 중인 동안 해당 터미널 세션은 해당 작업에 할당된니다.
    - 컨테이너를 중지하려면 Ctrl+C를 사용할 수 있다.
- 2번
    - 이 명령어는 spring-helloworld 이미지를 사용하여 컨테이너를 백그라운드 모드로 실행한다.
    - -d 옵션은 컨테이너를 백그라운드에서 실행하고 컨테이너 ID를 출력한 다음 즉시 터미널을 반환한다.
    - 이 모드에서는 컨테이너가 백그라운드에서 실행되며, 터미널을 사용하여 다른 작업을 계속할 수 있다.
    - 컨테이너의 로그를 보려면 docker logs [컨테이너 ID 또는 이름] 명령어를 사용해야 한다.

## DockerFile 작성하기

Dockerfile 은 도커 이미지를 구축하기 위해 명령어들을 순차적으로 나열한 텍스트 파일이다. 각각의 명령어는이미지의 새로운 계층을 만들어 내며, 이러한 계층들이 합쳐져 최종적인 이미지를 형성한다.

```docker
FROM maven:3.6.3-jdk-11 AS build
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn -f pom.xml clean package
```

```docker
FROM openjdk:11
WORKDIR /app
COPY --from=build /app/target/*.jar app.jar
EXPOSE 8080
CMD ["java", "-jar", "app.jar"]
```

1. Maven 기반 이미지를 사용하여 소스 코드를 컨테이너 내부로 복사하고, Maven을 사용해 애플리케이션을 빌드
2. OpenJDK 기반 이미지를 사용하여 빌드 단계에서 생성된 JAR 파일을 복사하고, Java 애플리케이션을 실행

### 기본 구조 및 명령어

1. **FROM**: 기반 이미지를 지정한다. 모든 `Dockerfile`은 `FROM` 명령어로 시작해야 하며, 이는 빌드 과
   정의 기점이 되는 이미지를 정의한다.

    ```docker
    FROM ubuntu:18.04
    ```

2. **LABEL**: 이미지에 메타데이터를 추가한다. 예를 들어, 이미지의 제작자 정보를 포함할 수 있다.

    ```docker
    LABEL [maintainer="name@example.com](mailto:maintainer=%22name@example.com)"
    ```

3. **RUN**: 이미지 빌드 과정 중에 명령어를 실행한다. 주로 패키지 설치나 설정 파일 변경에 사용된다.

    ```docker
    RUN apt-get update && apt-get install -y python
    ```

4. **COPY**: 호스트의 파일이나 디렉토리를 이미지 내부로 복사한다. 애플리케이션의 소스 코드를 이미지에 추가할 때
   주로 사용된다.

    ```docker
    COPY . /app
    ```

5. **ADD**: COPY 명령어와 유사하지만, 원격 URL에서 파일을 추가하거나 로컬의 압축 파일을 압축 해제하며 파일을 추가할 수 있다.

    ```docker
    ADD https://example.com/big.tar.xz /usr/src/things/
    ```

6. **CMD**: 컨테이너가 시작될 때 실행할 기본 명령어를 정의한다. Dockerfile 내에서 한 번만 사용할 수 있다.

    ```docker
    CMD ["python", "./app/app.py"]
    ```

7. **EXPOSE**: 컨테이너가 리스닝할 포트를 지정한다. 네트워킹 구성에 도움을 준다.

    ```docker
    EXPOSE 80
    ```

8. **ENV**: 환경 변수를 설정한다. 애플리케이션 설정에 사용된다.

    ```docker
    ENV API_KEY="YOUR_API_KEY"
    ```

9. **WORKDIR**: RUN , CMD , ENTRYPOINT , COPY , ADD 명령어가 실행될 작업 디렉토리를 설정한다.

    ```docker
    WORKDIR /app
    ```

10. **ENTRYPOINT**: 컨테이너가 시작될 때 실행할 명령어를 설정한다. CMD 와 함께 사용되어 애플리케이션의 실행 방식을 정의할 수 있다.

    ```docker
    ENTRYPOINT ["python"]
    CMD ["app.py"]
    ```


Dockerfile 을 준비한 후에는 docker build 명령어를 통해 이미지를 빌드할 수 있다. 이때 Dockerfile 내의 지시어들이 순서대로 실행되어 최종 이미지가 생성된다. Dockerfile 을 활용함으로써 애플리케이션의 빌드와 배포 과정을 표준화하고 자동화할 수 있으며, 이는 개발의 효율성을 높이는 데 기여한다.

## 실제 배포 체크 포인트

### 도커 이미지 최적화

도커 이미지의 크기를 줄이기 위한 Dockerfile 최적화 전략에는 여러 방법이 있다. 이미지의 효율성을 높이고, 배포 시간을 단축하며, 보안을 강화하는 데 중요하다.

1. **경량 베이스 이미지 사용하기**
   가능한 가장 경량의 베이스 이미지를 사용한다. 예를 들어, alpine 이미지는 매우 작은 크기로 필요한 최소한의 기능만 포함한다.
2. **멀티 스테이지 빌드 사용하기**
   Dockerfile 에서 멀티 스테이지 빌드를 사용하여 빌드 단계에만 필요한 도구를 최종 이미지에서 제외시킨다. 이 방식을 사용하면 최종 이미지에는 애플리케이션 실행에 필요한 파일과 디펜던시만 포함된다. 멀티 스테이지 빌드는 여러 개의 FROM 명령어를 사용하여 구현되며, 각 스테이지는 독립적인 베이스 이미지를 가질 수 있다. 첫 번째 스테이지에서는 빌드에 필요한 도구와 소스 코드를 컴파일하는 데 필요한 작업을 수행한다. 이후 스테이지에서는 첫번째 스테이지에서 생성된 아티팩트만을 가져와서 최종 이미지를 생성한다. 이렇게 하면 불필요한 빌드 도구나 중간 생성물을 최종 이미지에서 제외할 수 있어 이미지 크기가 상당히 줄어든다.
3. **필요 없는 파일 제거하기**
   빌드 과정에서 생성되는 임시 파일, 캐시 파일 등 필요 없는 파일은 RUN 명령어에서 && rm -rf
   /path/to/temporary/files 와 같이 제거하여 이미지 크기를 줄인다.
4. **레이어 수 최소화하기**
   RUN , COPY , ADD 명령어는 새로운 레이어를 생성한다. 이러한 명령어를 적절히 조합하여 가능한 한 적은 수의 레
   이어를 생성하도록 Dockerfile 을 최적화한다.
5. **COPY 와 ADD 명령어를 신중하게 사용하기**
   COPY 와 ADD 는 필요한 파일만 이미지에 추가하도록 사용한다. .dockerignore 파일을 사용하여 불필요한 파일이 이미지에 포함되지 않도록 설정할 수 있다.
6. **환경 변수를 이용한 설정하기**
   가능한 설정 파일 대신 환경 변수를 사용하여 애플리케이션을 구성한다. 이 방법은 설정 변경이 필요할 때 이미지를 다시 빌드하지 않아도 되므로 이미지 크기를 줄이는 데 도움이 된다.
7. **적절한 태그 사용하기**
   필요한 소프트웨어의 적절한 버전을 지정하여 불필요한 업데이트로 인한 크기 증가를 피한다.

### 실제 배포를 위해 컨테이너-호스트 간 파일 복사하기

docker cp 명령어는 실행 중인 도커 컨테이너와 호스트 사이에서 파일이나 디렉토리를 복사하는 데 사용한다. 이 명령어는 컨테이너의 파일 시스템과 호스트의 파일 시스템 간의 데이터를 쉽게 이동할 수 있게 한다.

- 호스트에서 컨테이너로 파일이나 디렉토리 복사하기

    ```bash
    docker cp <호스트의 파일 경로><컨테이너 이름>:<컨테이너 내 경로>
    ```

- 컨테이너에서 호스트로 파일이나 디렉토리 복사하기

    ```bash
    docker cp <호스트의 파일 경로><컨테이너 이름>:<컨테이너 내 경로>
    ```


## Docker compose 개념

- 도커 컴포즈는 여러 컨테이너를 정의하고 실행하기 위한 도구다. YAML 파일을 사용하여 애플리케이션의 서비스, 네트워크, 볼륨 등을 구성하고, 이 파일을 기반으로 한 명령어로 모든 서비스를 빌드하고 시작할 수 있다.
- 도커 컴포즈는 복잡한 멀티 컨테이너 애플리케이션을 쉽게 관리하고, 개발, 테스팅, 스테이징, 프로덕션 환경에서의 일관성을 보장하는 데 유용하다.

<aside>
💡 **도커 컴포즈 주요 특징**

1. **간편한 구성**: docker-compose.yml 파일 하나로 전체 애플리케이션 스택의 설정을 관리할 수 있다. 이 YAML 파일에는 애플리케이션을 구성하는 모든 컨테이너, 그 컨테이너들이 사용할 이미지, 포트 매핑, 볼륨 마운트, 환경 변수 등이 정의된다.
2. **명령어 단순화**: 도커 컴포즈는 docker-compose up , docker-compose down 같은 간단한 명령어를 통해 서비스를 생성, 시작, 중지할 수 있다. 이는 개발 과정을 효율적으로 만들어 준다.
3. **개발 효율성 증대**: 개발자는 로컬 환경에서 전체 애플리케이션을 손쉽게 시뮬레이션하고 테스트할 수 있다. 컨테이너화된 환경 덕분에 다른 개발자나 환경과의 충돌 없이 독립적으로 작업할 수 있다.
4. **환경 일관성 보장**: 도커 컴포즈를 사용하면 개발부터 프로덕션까지 애플리케이션의 환경을 일관되게 유지할 수 있다. 이는 "개발 환경에서는 잘 동작했는데, 실제 환경에서는 안 된다"는 문제를 방지해 준다.
5. **다중 서비스 관리**: 복잡한 애플리케이션을 구성하는 다수의 서비스(예: 데이터베이스, 백엔드, 프론트엔드 등)를 한 번에 관리할 수 있다. 각 서비스는 독립적인 컨테이너로 실행되지만, 도커 컴포즈를 통해 서로 연결되고 조율된다.
</aside>

1. **버전 (version)**
   도커 컴포즈 파일의 버전을 명시한다. 버전에 따라 사용할 수 있는 구성 옵션이 다르며, 일반적으로 최신 버전을 사
   용하는 것이 좋다.

    ```yaml
    version: '3'
    ```

2. **서비스 (services)**
   애플리케이션을 구성하는 컨테이너들을 정의한다. 각 서비스는 하나의 컨테이너를 의미하며, 도커 이미지, 포트 바인딩, 볼륨 마운트 등 컨테이너를 실행하기 위한 설정을 포함한다.

    ```yaml
    services:
    	web:
    	image: nginx
    	ports:
    		- "8080:80"
    db:
    	image: postgres
    	volumes:
    		- db-data:/var/lib/postgresql/data
    
    ```

3. **네트워크 (networks)**
   컨테이너 간 통신을 위한 네트워크를 정의한다. 사용자 정의 네트워크를 생성하여 서비스들이 통신할 수 있는 네트워크 환경을 구성할 수 있다.

    ```yaml
    networks:
    	app-network:
    ```

4. **볼륨 (volumes)**
   데이터를 영구적으로 저장하기 위한 볼륨을 정의한다. 볼륨은 컨테이너가 삭제되어도 데이터를 보존하며, 여러 컨테이너 간에 데이터를 공유할 수 있도록 한다.

    ```yaml
    volumes:
    	db-data:
    ```

5. **기타 구성 요소**
   환경변수, 컨테이너 종속성, 컨테이너 구성 옵션, 비밀 키 등 추가적인 구성 요소를 정의하여 더욱 복잡한 애플리케이션을 관리할 수 있다.
   도커 컴포즈 파일을 사용하면 여러 컨테이너로 구성된 애플리케이션을 한 곳에서 관리할 수 있으며, docker-compose up 명령어 하나로 모든 서비스를 시작하고, docker-compose down명령어로 중지시킬 수 있다.

## Volumes

- container는 불변하지 않는다. 한번 사용되는 개념. 인스턴스와 유사
- **데이터의 영구성**: 볼륨에 저장된 데이터는 컨테이너가 삭제되어도 보존된다. 따라서 중요한 데이터를 안전하게 관리할 수 있다.
- **데이터 공유 및 재사용**: 볼륨은 여러 컨테이너 간에 마운트되어 공유될 수 있어, 다양한 컨테이너에서 동일한 데이터에 접근하거나 재사용할 수 있다.
- **데이터 백업, 복구 및 마이그레이션**: 볼륨을 사용하면 데이터를 백업하고 필요할 때 복구하는 것이 용이하다. 또한, 볼륨을 이용해 데이터를 한 호스트에서 다른 호스트로 쉽게 이동할 수 있다.

```yaml
docker volume create : 새로운 볼륨을 생성한다.
docker volume ls : 생성된 볼륨 목록을 조회한다.
docker volume rm : 지정한 볼륨을 삭제한다.
docker volume inspect : 지정한 볼륨의 상세 정보를 조회한다.
```

볼륨을 컨테이너에 마운트하기 위해서는`docker run` 명령어 실행 시 `-v` 또는 `—mount`플래그를 사용한다.

## Network

- 네트워크란? 노드와 노드간의 커뮤니케이션
- 컨테이너와 컨테이너 따로 만들면 그냥 연결이 안된다.
  → 가상 네트워크를 만들고 이 네트워크에 컨테이너를 소속시켜 컨테이너들을 연결한다.
1. **사용자 정의 네트워크 생성**

    ```bash
    docker network create redmine-network
    ```

2. **MySQL 컨테이너 실행**

    ```bash
    docker run --name some-mysql --network redmine-network -e MYSQL_ROOT_PASSWORD=my-secret-pw -e MYSQL_DATABASE=redmine -d mysql:8
    ```

3. **레드마인 컨테이너 실행**

    ```bash
    docker run --name some-redmine --network redmine-network -e REDMINE_DB_MYSQL=some-mysql -e REDMINE_DB_PASSWORD=my-secret-pw -p 3000:3000 -d redmine
    ```


## Docker network의 종류

- 브릿지 네트워크 먼저 핵심 포인트! 나머지는 Devops 의 영역!
- 도커 네트워크는 컨테이너 간의 통신과 외부 네트워크와의 연결을 관리하는 도커의 기능이다. 이를 통해 개발자는 컨테이너가 서로 어떻게 통신할 수 있는지, 어떤 정책으로 네트워크를 격리할 것인지를 정의할 수 있다. 도커 네트워크는 여러 네트워크 드라이버를 지원하며, 각각의 사용 사례에 따라 적합한 네트워크 환경을 구성할 수 있다.

### 1. 브리지 네트워크 (Bridge Network)

- 정의: 기본적으로, 각 도커 설치에는 하나의 브리지 네트워크가 존재하며, 컨테이너를 실행할 때 이 네트워크에 자동으로 연결된다. 사용자는 여러 개의 사용자 정의 브리지 네트워크를 생성하여 컨테이너를 논리적으로 분리할 수 있다.
- 사용 사례: 같은 브리지 네트워크에 속한 컨테이너끼리는 서로 통신할 수 있지만, 다른 브리지 네트워크에 속한 컨테이너와는 통신할 수 없다. 이를 통해 애플리케이션의 컴포넌트를 격리할 수 있다.